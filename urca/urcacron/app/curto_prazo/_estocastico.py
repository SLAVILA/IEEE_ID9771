# -*- coding: utf-8 -*-
"""Final_Curto_Prazo_sem_ena_de_ModelPredictions_WithCovariable_20240303LogPricesNewDataPLD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-3zqfRzXoo9K9lHixDHnX1uOfM-AYOH3

### (Sem ENA) ModelPredictions_WithCovariable_20240303LogPricesNewDataPLD
"""
import sys
from flask import copy_current_request_context
import json
import os
from flask import current_app, request, session
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from scipy.optimize import least_squares
#from scipy.optimize import minimize
#import seaborn as sns
import matplotlib.pyplot as plt
from app.curto_prazo import b_curto_prazo
from plotly.io import to_json
from biblioteca import task
import plotly.tools as tls
import mpld3
import shutil
import plotly.io as pio
import plotly.graph_objects as go
from plotly.io import to_json
import plotly.offline as pyo
from scipy.sparse import coo_matrix #sparse

script_dir = os.path.dirname(__file__)

def ObjFunMRLJumps_20230629ReturnsB(data,coef,coef0,t,dt,beta0,alpha):
    kappa = coef[0]
    theta = 0
    xi = coef[1]
    lmbda = coef[2]
    mu = coef[3]
    sigma = coef[4]
    t = t*dt
    leng = len(t)

    xi2 = xi**2
    lmbda2 = lmbda**2
    sigma2 = sigma**2
    integral = lmbda2*np.exp(1.5*mu**2/sigma2)*(np.exp(8*sigma2+4*mu)-2*np.exp(2*sigma2+2*mu)+1)
    data2 = data ** 2    #eleva cada elemento ao quadrado
    a = xi2 + integral

    MeanBeta = beta0*np.exp(-kappa*t)
    MeanBetaSqr = beta0**2*np.exp(-2*kappa*t) + np.exp(-2*kappa*t)*(a*((np.exp(2*kappa*t)-1)/2*kappa))   #NOVO
    f = np.sqrt(np.abs(MeanBetaSqr -2*data[1:leng+1]*MeanBeta + data2[1:leng+1])) #data(2:leng+1)=(2:61) em matlab equivale a data[1:leng+1]=[1:60] em python
    f=f/np.maximum(np.array([1E-4] * leng), data2[1:leng+1])
    #f = np.concatenate((f, alpha * (coef - coef0), alpha * coef))
    f = np.linalg.norm(f) ** 2 + np.linalg.norm( alpha * (coef - coef0)) ** 2 + np.linalg.norm(alpha * coef) **2
    return f


##############################################################  Gráfico de Análise de Risco     #Risco => função nova

def plot_risk(VAR, CVAR, jj, k, leng, dates, Title, yy):
    fig = go.Figure()

    # Converter valores para strings com uma casa decimal
    high_mark_text = [f'{x:.1f}%' for x in 100*VAR[jj,:,k]]
    low_mark_text = [f'{x:.1f}%' for x in 100*CVAR[jj,:,k]]

    dates_prev = pd.concat([dates, pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])

    # Obter data do plot
    try:
        data_plot = dates.iloc[jj + leng:jj + leng + 1].dt.strftime('%d/%m/%Y').item()
    except (AttributeError, IndexError) as e:
        try:
            date_str = dates.iloc[jj + leng:jj + leng + 1].item()
            data_plot = pd.to_datetime(date_str).strftime('%d/%m/%Y')
        except Exception as e:
            print(f"Erro ao acessar ou formatar a data: {e}")
            data_plot = None

    # Adicionar barras para 'tendencia de alta', 'tendencia de baixa' e 'estagnação' com o valor no topo
    fig.add_trace(go.Bar(x=dates_prev[jj+leng + 1:jj+leng + 16], y=100*VAR[jj,:,k], name='VaR 5%',
                         text=high_mark_text, textposition='outside', marker_color='blue'))
    fig.add_trace(go.Bar(x=dates_prev[jj+leng + 1:jj+leng + 16], y=100*CVAR[jj,:,k], name='cVaR 5%',
                         text=low_mark_text, textposition='outside', marker_color='green'))

    # Calcular o valor absoluto máximo para configurar o eixo y simétrico
    max_value = max(np.abs(100 * VAR[jj, :, k]).max(), np.abs(100 * CVAR[jj, :, k]).max()) + 2

    # Atualizar layout
    fig.update_layout(
        title=Title,
        xaxis_title='Data',
        yaxis_title='Valor (%)',
        barmode='group',
        hovermode='x',
        xaxis=dict(
            tickmode='array',
            tickvals=dates_prev[jj+leng + 1:jj+leng + 16],
            tickformat='%d/%m',
            tickangle=-30
        ),
        yaxis=dict(
            range=[-max_value * 1.2, max_value * 1.2],  # Define limites simétricos para o eixo y
            zeroline=True,  # Adiciona uma linha no zero para referência
        ),
        font=dict(
            family='Poppins, Helvetica, sans-serif',
            size=12,
            color='black'
        ),
    )

    # Convert Plotly figure to JSON
    plot_json = to_json(fig)
    
    output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}')
    os.makedirs(os.path.join(output_dir, 'risco'), exist_ok=True)
    nome_arquivo = f"estocastico_{data_plot.replace(' ', '_').replace('-', '_').replace('/', '_')}.json"
    with open(os.path.join(output_dir, 'risco', nome_arquivo), 'w') as f:
        json.dump(plot_json, f)
                
    print(f"Gráfico dash salvo em: {os.path.join(output_dir, 'risco', nome_arquivo)}")

#Risco_20240412 => Será usada sempre a mesma. Só mudará a entrada em cada contexto. #Risco  => Função nova

def Risco_20240412(sign):

    var05= - np.percentile(sign,5, axis = 1)
    cvar05=np.zeros(len(var05))

    for ii in range(len(var05)):
        aux = sign[ii,:]
        aux = aux[aux<=-var05[ii]]
        cvar05[ii] = - np.sum(aux)/len(aux)

    return 'var05 = ', var05, 'cvar05 = ', cvar05

def MRJ_plot(dates, Prices, lPld, logPricesSqrLMRJ, logPricesLMRJ, jj, leng, len_pred, yy):   #NOVO
                
                
                
    global data_antiga  # Use a variável global para manter o estado entre chamadas

    try:
        # Tenta acessar a data e formatar
        data_plot = dates.iloc[jj + leng:jj + leng + 1].dt.strftime('%d/%m/%Y').item()
    except (AttributeError, IndexError) as e:
        try:
            # Se der erro, tenta converter para datetime e formatar
            date_str = dates.iloc[jj + leng:jj + leng + 1].item()
            data_plot = pd.to_datetime(date_str).strftime('%d/%m/%Y')
        except Exception as e:
            print(f"Erro ao acessar ou formatar a data: {e}")
            data_plot = None  # ou algum valor padrão ou mensagem de erro
                        
    # print(f"Plot: {data_plot} está sendo salvo. - JJ: {jj}")


    # print(f"jj: {jj}")
    # Verificação das dimensões para evitar erros de indexação
    #if jj - leng < 0:                                                           #Pedro, removi linha
        # Se os índices não forem válidos, retorna
    #    return

    aux = np.sqrt(np.abs(logPricesSqrLMRJ - logPricesLMRJ**2))
    PredM = np.exp(logPricesLMRJ)
    PredL = np.exp(logPricesLMRJ - aux)
    PredU = np.exp(logPricesLMRJ + aux)

    for zz in range(len(PredM)):
        PredM[zz] = max(PredM[zz], np.exp(lPld[zz, 0]))
        PredM[zz] = min(PredM[zz], np.exp(lPld[zz, 1]))
        PredL[zz] = max(PredL[zz], np.exp(lPld[zz, 0]))
        PredL[zz] = min(PredL[zz], np.exp(lPld[zz, 1]))
        PredU[zz] = max(PredU[zz], np.exp(lPld[zz, 0]))
        PredU[zz] = min(PredU[zz], np.exp(lPld[zz, 1]))

    dates_prev = pd.concat([dates, pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])

    fig = go.Figure()

    if jj < Prices.shape[0] - 2 * leng:
        fig.add_trace(go.Scatter(x=dates_prev[jj:jj + leng + len_pred + 1], y=Prices[jj:jj+leng+ len_pred + 1], mode='lines', name='Observado', line=dict(color='black')))
    else:
        max_length = min(Prices.shape[0] - jj, leng + len_pred + 1)                        #Alteração_7
        fig.add_trace(go.Scatter(x=dates_prev[jj:jj + max_length], y=Prices[jj:jj + max_length], mode='lines', name='Observado', line=dict(color='black')))
    

    fig.add_trace(go.Scatter(x=dates_prev[jj + leng:jj + leng + len_pred + 1], y=PredM[:len_pred + 1], mode='lines', name='Previsão', line=dict(color='magenta')))
    
    fig.add_trace(go.Scatter(x=dates_prev[jj + leng:jj + leng + len_pred + 1], y=PredL[:len_pred + 1], mode='lines', fill=None, line=dict(color='orange', width=0), showlegend=False))
    fig.add_trace(go.Scatter(x=dates_prev[jj + leng:jj + leng + len_pred + 1], y=PredU[:len_pred + 1], mode='lines', fill='tonexty', line=dict(color='orange', width=0), name='Desvio Padrão'))

    fig.add_trace(go.Scatter(x=dates_prev[jj:jj + leng + len_pred + 1], y=np.exp(np.min(lPld)) * np.ones(len(dates_prev[jj:jj + leng + len_pred + 1])), mode='lines', line=dict(color='black', dash='dash'), showlegend=False))
    fig.add_trace(go.Scatter(x=dates_prev[jj:jj + leng + len_pred + 1], y=np.exp(np.max(lPld)) * np.ones(len(dates_prev[jj:jj + leng + len_pred + 1])), mode='lines', line=dict(color='black', dash='dash'), showlegend=False))

    fig.update_layout(
        title='Reversão à Média com Saltos',
        xaxis_title='Tempo',
        yaxis_title='VWAP',
        showlegend=True,
        xaxis=dict(
            tickmode='array',
            tickformat='%d/%m',  # Formato para o eixo x
            tickangle=-30
        ),
        font=dict(
            family='Poppins, Helvetica, sans-serif',  # Especifique a família de fontes desejada
            size=12,  # Tamanho da fonte global
            color='black'  # Cor da fonte global
        ),
    )

    # Convert Plotly figure to JSON
    plot_json = to_json(fig)
    
    output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}')
    
    # Save the JSON file
    output_file = os.path.join(output_dir, 'output')
    os.makedirs(output_file, exist_ok=True)
    with open(os.path.join(output_file, f'estocastico_saida_{str(data_plot).replace("/", "_").strip()}.json'), 'w') as f:
        json.dump(plot_json, f)
    #fig.write_html(os.path.join(output_file, f'estocastico_saida_{str(dates[jj+leng]).replace("00:00:00", "").replace("-", "_").strip()}.html'))
        

def Acertar(t,estag, signLMRJ, NSamples, P0, Pdata2): #Pedro, estag se tornou uma entrada. Removi a linha que definia estag.

    #estag = estag/100, dependendo da entrada.

    AUX = np.zeros((len(t),3))
    AUX2 = np.zeros((len(t),3))
    acertou = np.zeros(len(t))

    AT=(Pdata2[:-1]-P0)/P0

    for ii in range(len(t)):
        AUX[ii,0] = np.sum(signLMRJ[ii,:]>estag)/NSamples
        AUX[ii,1] = np.sum(signLMRJ[ii,:]<-estag)/NSamples
        AUX[ii,2] = 1 - AUX[ii,0] - AUX[ii,1]
        if AT[ii] > estag:
            AUX2[ii,0] = 1
        elif AT[ii] < -estag:
            AUX2[ii,1] = 1
        elif AT[ii] <= estag and AT[ii] >= -estag:
            AUX2[ii,2] = 1

        aux1 = np.argmax(AUX[ii,:]) # np.argmax: Returns the indices of the maximum values along an axis. In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.
        aux2 = np.argmax(AUX2[ii,:])
        if aux1 == aux2:
            acertou[ii] = 1

    return  "AT = ", AT, "AUX =", AUX, "AUX2 = ", AUX2,  "acertou = ", acertou        

def MC(leng, S02, coefLMRJ, dt, LevelPred, NSamples, t, lPld): #Pedro, troquei S0 por S02 na linha de definição
    kappa = coefLMRJ[0]
    xi = coefLMRJ[1]
    lmbda=coefLMRJ[2]
    mu = coefLMRJ[3]
    sigma=coefLMRJ[4]

    rng = np.random.default_rng()
    A = rng.poisson(lam = dt, size = (int(len(t)), int(NSamples)))
    A = np.concatenate((np.zeros((1,int(NSamples))), A), axis = 0)
    W = np.sqrt(dt)*np.random.randn(len(t), int(NSamples))
    W = np.concatenate((np.zeros((1, int(NSamples))), W), axis=0)
    B = np.random.normal(mu, sigma, (len(t), int(NSamples)))
    B = np.concatenate((np.zeros((1,int(NSamples))), B), axis = 0)
    B = B*A
    X= np.zeros((len(t)+1,int(NSamples))) #######
    X[0,:] = S02  #
    Xtemp = X[0,:]/xi
    aux=LevelPred[leng+1:]
    X[0,:]=X[0,:]+aux[0]

    for ii in range(len(t)):
        Xtemp = Xtemp - kappa*Xtemp*dt + W[ii,:] + lmbda/xi*B[ii,:]
        X[ii+1,:]= np.minimum(lPld[leng+1+ii,1], np.maximum(lPld[leng+1+ii,0], xi*Xtemp+aux[ii+1]))
        #X[ii+1,:]= np.minimum(lPld[leng+1+ii,1], np.maximum(lPld[leng+1+ii,0], xi*Xtemp))

    L = np.percentile(X, 5, axis=1)
    M = np.median(X, axis = 1)
    U = np.percentile(X, 95, axis=1)

    return "X= ", X, "L= ", L, "M = ", M, "U = ", U #MUDEI



def Error(prices, leng, coefLMRJ, dt, LevelPred, data, Data,fLMRJ_IN, fLMRJ_OUT): #Pedro, retirei S0 por não ser usado

    errorLMRJ = np.zeros(2)
    ErrorLMRJ = np.zeros(leng)

    fLMRJ_T = np.concatenate((fLMRJ_IN, fLMRJ_OUT))


    len1 = 15

    aux=fLMRJ_OUT/np.linalg.norm(Data[leng:])
    ErrorLMRJ = aux[0: ErrorLMRJ.shape[0]]
    errorLMRJ[0] = np.linalg.norm(fLMRJ_IN/np.linalg.norm(data))
    errorLMRJ[1] = np.linalg.norm(fLMRJ_T[leng:leng+len1])/np.linalg.norm(Data[leng:leng+len1])

    return "ErrorLMRJ = ", ErrorLMRJ, 'errorLMRJ = ', errorLMRJ, 'fLMRJ_T', fLMRJ_T

def evaluate(leng, S0, coefLMRJ, dt, LevelPred, DataB, dataB2, data, Data, P0, type):
    # Data só é usada em "out". Na implementação: Data = Data[leng:].
    # data só é usada em "in". Na implementação: data = data.
    kappa = coefLMRJ[0]
    theta = 0
    xi = coefLMRJ[1]
    lmbda=coefLMRJ[2]
    mu = coefLMRJ[3]
    sigma=coefLMRJ[4]
    xi2 = xi ** 2
    lmbda2=lmbda ** 2
    sigma2=sigma ** 2;
    integral = lmbda2*np.exp(1.5*mu**2/sigma2)*(np.exp(8*sigma2+4*mu)-2*np.exp(2*sigma2+2*mu)+1)
    #data2 = Data ** 2
    a = xi2 + integral

    meanLMRJ = np.zeros(leng)
    fLMRJ = np.zeros((LevelPred.shape))
    MeanBeta = S0 * np.exp(-kappa*np.arange(leng+1)*dt) # np.arange(leng+1) = {0,...,60} = [0:t] em matlab
    meanLMRJ[0:leng] = MeanBeta[0:leng]
    MeanBetaSqr = S0**2 * np.exp(-2*kappa*np.arange(leng+1)*dt) + np.exp(-2*kappa*np.arange(leng+1)*dt)*(a*np.arange(leng+1)*dt)
    aux = np.sqrt(np.abs(MeanBetaSqr+2*MeanBeta*LevelPred+LevelPred**2-2*(MeanBeta+LevelPred)*DataB + dataB2))
    fLMRJ = aux[1:]
    logPricesLMRJ = MeanBeta
    logPricesSqrLMRJ = MeanBetaSqr

    len1 = 15

    rmseLMRJ = np.zeros((LevelPred.shape))
    mapeLMRJ = np.zeros((LevelPred.shape))
    corrLMRJ = np.zeros((LevelPred.shape))
    maeLMRJ = np.zeros((LevelPred.shape))
    mbeLMRJ = np.zeros((LevelPred.shape))
    mseLMRJ = np.zeros((LevelPred.shape))
    ioaLMRJ = np.zeros((LevelPred.shape))

    if type == "in":

        # RMSE
        rmseLMRJ = np.linalg.norm(fLMRJ[0:leng])/np.sqrt(leng)

        # MAPE
        mapeLMRJ = np.sum(np.abs((meanLMRJ[0:leng]-data[0:leng])/meanLMRJ[0:leng]))/leng

        # Pearson Correlation
        aux = np.sum((meanLMRJ[0:leng]-np.mean(meanLMRJ[0:leng]))*(data[0:leng]-np.mean(data[0:leng])))
        aux = aux/np.sqrt(np.sum((meanLMRJ[0:leng]-np.mean(meanLMRJ[0:leng]))**2)*np.sum((data[0:leng]-np.mean(data[0:leng]))**2))
        corrLMRJ = aux

        # MAE
        maeLMRJ = np.sum(np.abs((meanLMRJ[0:leng]-data[0:leng])))/leng

        # MBE
        mbeLMRJ = np.sum((meanLMRJ[0:leng]-data[0:leng]))/leng


        # MSE
        mseLMRJ = np.sum((fLMRJ[0:leng])**2)/leng


        # Wilmott Index of Agreement (IOA)
        aux = np.sum((meanLMRJ[0:leng]-data[0:leng])**2)
        aux = aux/np.sum((np.abs(meanLMRJ[0:leng]-np.mean(data[0:leng]))+np.abs(data[0:leng]-np.mean(data[0:leng])))**2)
        ioaLMRJ = 1-aux

        ALMRJ = 'empty'

    elif type == "out":


        ALMRJ=(P0*np.exp(MeanBeta[1:]+LevelPred[1:])-P0)/P0

        # RMSE
        rmseLMRJ = np.linalg.norm(fLMRJ[0:len1])/np.sqrt(len1)

        # MAPE
        mapeLMRJ = np.sum(np.abs((meanLMRJ[0:len1]-Data[0:len1])/meanLMRJ[0:len1]))/len1

        # Pearson Correlation
        aux = np.sum((meanLMRJ[0:len1]-np.mean(meanLMRJ[0:len1]))*(Data[0:len1]-np.mean(Data[0:len1])))
        aux = aux/np.sqrt(np.sum((meanLMRJ[0:len1]-np.mean(meanLMRJ[0:len1]))**2)*np.sum((Data[0:len1]-np.mean(Data[0:len1]))**2))
        corrLMRJ = aux

        # MAE
        maeLMRJ = np.sum(np.abs(meanLMRJ[0:len1]-Data[0:len1]))/len1

        # MBE
        mbeLMRJ = np.sum(meanLMRJ[0:len1]-Data[0:len1])/len1

        # MSE
        mseLMRJ = np.sum((fLMRJ[0:len1])**2)/len1


        # Wilmott Index of Agreement (IOA)
        aux = np.sum((meanLMRJ[0:len1]-Data[0:len1])**2)
        aux = aux/np.sum((np.abs(meanLMRJ[0:len1]-np.mean(Data[0:len1]))+np.abs(Data[0:len1]-np.mean(Data[0:len1])))**2)
        ioaLMRJ = 1-aux

    return "fLMRJ = ", fLMRJ, 'logPricesLMRJ = ', logPricesLMRJ, 'logPricesSqrLMRJ = ', logPricesSqrLMRJ, 'rmseLMRJ', rmseLMRJ, 'mapeLMRJ', mapeLMRJ, 'corrLMRJ', corrLMRJ, 'maeLMRJ', maeLMRJ, 'mbeLMRJ', mbeLMRJ, 'mseLMRJ', mseLMRJ, 'ioaLMRJ', ioaLMRJ, 'ALMRJ =', ALMRJ

##############################################################  Figura para a Dash principal



# Converter datas para strings sem horas
#date_text = df_dados['date'].dt.strftime('%Y-%m-%d')

# Criar o gráfico de barras

def plot_prob(SignLMRJ1, SignLMRJ2, SignLMRJ3, jj, leng, dates, yy):
    fig = go.Figure()

    # Converter valores para strings com uma casa decimal
    high_mark_text = [f'{x:.1f}' for x in 100*SignLMRJ1[jj,:]] #1:16]] #plot
    low_mark_text = [f'{x:.1f}' for x in 100*SignLMRJ2[jj, :]] #1:16]] #plot
    estag_mark_text = [f'{x:.1f}' for x in 100*SignLMRJ3[jj, :]] #1:16]] #plot

    dates_prev = pd.concat([dates,pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])     #1/8

    # obter data do plot
    try:
        # Tenta acessar a data e formatar
        data_plot = dates.iloc[jj + leng:jj + leng + 1].dt.strftime('%d/%m/%Y').item()
    except (AttributeError, IndexError) as e:
        try:
            # Se der erro, tenta converter para datetime e formatar
            date_str = dates.iloc[jj + leng:jj + leng + 1].item()
            data_plot = pd.to_datetime(date_str).strftime('%d/%m/%Y')
        except Exception as e:
            print(f"Erro ao acessar ou formatar a data: {e}")
            data_plot = None  # ou algum valor padrão ou mensagem de erro
            
    # Adicionar barras para 'tendencia de alta', 'tendencia de baixa' e 'estagnação' com o valor no topo
    fig.add_trace(go.Bar(x= dates_prev[jj+leng +1 :jj+leng + 16], y= 100*SignLMRJ1[jj,:], name='Tendência de alta', #plot        #1/8
                        text=high_mark_text, textposition='outside', textangle=90, marker_color='blue', showlegend=False))
    fig.add_trace(go.Bar(x= dates_prev[jj+leng +1 :jj+leng + 16], y= 100*SignLMRJ2[jj,:], name='Tendência de baixa', #plot       #1/8
                        text=low_mark_text, textposition='outside', textangle=90, marker_color='red', showlegend=False))
    fig.add_trace(go.Bar(x= dates_prev[jj+leng +1 :jj+leng + 16], y= 100*SignLMRJ3[jj,:], name='Estagnação', #plot               #1/8
                        text=estag_mark_text, textposition='outside', textangle=90, marker_color='yellow', showlegend=False))

    # Adicionar tooltip customizado
    fig.update_traces(
        hovertemplate=
        'Data: %{x|%Y-%m-%d}<br>Probabilidade: %{y:.1f}%<br>'
    #+
    #    'Lower Percentile: %{customdata[0]:.1f}<br>' +
    #    'Upper Percentile: %{customdata[1]:.1f}<br>' +
    #    'Median Percentile: %{customdata[2]:.1f}'
    )

    # Adicionar os valores de 'lowerp_mark', 'upperp_mark' e 'medp_mark' como customdata
    #fig.data[0].update(customdata=np.stack((df_dados['lowerp_mark'], df_dados['upperp_mark'], df_dados['medp_mark']), axis=-1))
    #fig.data[1].update(customdata=np.stack((df_dados['lowerp_mark'], df_dados['upperp_mark'], df_dados['medp_mark']), axis=-1))
    #fig.data[2].update(customdata=np.stack((df_dados['lowerp_mark'], df_dados['upperp_mark'], df_dados['medp_mark']), axis=-1))

    # Atualizar layout
    fig.update_layout(
        title='Previsão Estocástica',
        xaxis_title='Data',
        yaxis_title='Probabilidade (%)',
        barmode='group',  # agrupar barras lado a lado
        hovermode='x',
        xaxis=dict(
            tickmode='array',
            tickvals=dates_prev[jj+leng +1 :jj+leng + 16],                        #1/8
            #ticktext=date_text,
            tickformat='%d/%m',  # Formato para o eixo x
            tickangle=-30
        ),
        font=dict(
            family='Poppins, Helvetica, sans-serif',  # Especifique a família de fontes desejada
            size=12,  # Tamanho da fonte global
            color='black'  # Cor da fonte global
        ),
    )
    # save it
    output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}')
    fig_json = to_json(fig)
    os.makedirs(os.path.join(output_dir, 'dash'), exist_ok=True)
    nome_arquivo = f"estocastico_{data_plot.replace(' ', '_').replace('-', '_').replace('/', '_')}.json"
    with open(os.path.join(output_dir, 'dash', nome_arquivo), 'w') as f:
        json.dump(fig_json, f)
                
    print(f"Gráfico dash salvo em: {os.path.join(output_dir, 'dash', nome_arquivo)}")
    return fig_json

def Acertar_plot(estag, signLMRJ, NSamples): #plot. Função nova.

    #estag = estag/100, dependendo da entrada.

    AUX = np.zeros((15,3))

    for ii in range(15):
        AUX[ii,0] = np.sum(signLMRJ[ii,:]>estag)/NSamples
        AUX[ii,1] = np.sum(signLMRJ[ii,:]<-estag)/NSamples
        AUX[ii,2] = 1 - AUX[ii,0] - AUX[ii,1]

    return  "AUX =", AUX

def notificar(mensagem, usuario_id=None):
    if usuario_id:
        current_app.notify_clients(mensagem, user_ids=[usuario_id])
    else:
        current_app.notify_clients(mensagem, user_ids=[session['usuario']['id']])

@b_curto_prazo.route("/_estocastico_dash", methods=["POST"])
def _estocastico_dash():
    try:
        m = request.form.get('m')
        directory = os.path.join('web', 'static', 'tasks_saida', 'estocastico', m, 'dash')
        data = request.form.get('data')

        # List all files in the directory
        files = os.listdir(directory)

        # Filter files that match the pattern 'estocastico_DATE.json'
        estocastico_files = [f for f in files if f.startswith('estocastico_') and f.endswith('.json')]

        if not estocastico_files:
            return json.dumps({"status": "1", "msg": "Nenhum arquivo encontrado."})

        if data:
            # Formata a data de entrada para o formato dos arquivos
            formatted_date = datetime.strptime(data, '%d/%m/%Y')

            # Função para reduzir a data até encontrar um arquivo válido
            def encontrar_arquivo_por_data(data_inicial, arquivos):
                while True:
                    formatted_str = data_inicial.strftime('%d_%m_%Y')
                    for file in arquivos:
                        file_date_str = file.split('_')[1] + '_' + file.split('_')[2] + '_' + file.split('_')[3].split('.')[0]
                        if file_date_str == formatted_str:
                            return file, formatted_str
                    # Se não encontrou, reduz a data em 1 dia
                    data_inicial -= timedelta(days=1)
                    # Opcional: limite de redução de datas (ex: até 1 ano atrás)
                    if data_inicial < datetime.now() - timedelta(days=365):
                        break
                return None, None

            # Tenta encontrar o arquivo mais próximo
            selected_file, file_date_str = encontrar_arquivo_por_data(formatted_date, estocastico_files)

            if not selected_file:
                return json.dumps({"status": "1", "msg": "Nenhum arquivo encontrado para a data fornecida ou anterior válida."})
        else:
            # Retorna o plot do arquivo mais recente
            selected_file = max(estocastico_files, key=lambda x: datetime.strptime('_'.join(x.split('_')[1:4]).split('.')[0], '%d_%m_%Y'))
            file_date_str = selected_file.split('_')[1] + '_' + selected_file.split('_')[2] + '_' + selected_file.split('_')[3].split('.')[0]

        # Abrir o arquivo selecionado
        with open(os.path.join(directory, selected_file), 'r') as f:
            plot_json = json.load(f)

    except Exception as e:
        return json.dumps({"status": "1", "msg": f"Erro: {str(e)}"})

    return json.dumps({"status": "0", "plot": plot_json, "data": file_date_str.replace('_', '/')})



@b_curto_prazo.route("/_estocastico_auxiliar", methods=["POST"])
def _estocastico_auxiliar():
    tipo = request.form.get('tipo')
    try:
        output_file = os.path.join('web', 'static', 'tasks_saida', 'estocastico', tipo, 'estocastico.json')
        with open(output_file, 'r') as f:
            plot_json = json.load(f)
    except:
        return json.dumps({"status": "1", "msg": "Gráfico não encontrado."})
    return json.dumps({"status": "0", "plot": plot_json})

@b_curto_prazo.route("/_estocastico_obter", methods=["POST"])
def _estocastico_obter():
    tipo = request.form.get('tipo')
    m = request.form.get('m')
    nome_arquivo = f'estocastico_saida_{tipo}.json'
    output_file = os.path.join('web', 'static', 'tasks_saida', 'estocastico', m, 'output', nome_arquivo)
    
    # Read the HTML file
    with open(output_file, 'r') as f:
        plot_json = json.load(f)
    
    return json.dumps({"status": "0", "plot": plot_json})

def estocastico(user_id, leng_n, estag, make_plot=False):
    # obter primeiro arg
    ### Função

    #ObjFunMRLJumps_20230629ReturnsB
    #import numpy as np
    
    output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico')
    # if os.path.exists(output_dir):
    #     shutil.rmtree(output_dir, ignore_errors=True)
    os.makedirs(output_dir, exist_ok=True)

    dados_path = os.path.join(script_dir, 'dados_preco', 'linear interpol', 'interpolacao linear')
        
    global data_antiga
        
    data_antiga = datetime(1970, 1, 1, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)

    ### Modeling using Prices directly

    Bounds = np.array([[219, 1287], [226, 1546], [197, 1354], [72, 1084]])
    name = 'rolloff suavizado'
    acron = 'RS'

    pld = pd.read_excel(os.path.join(script_dir, 'dados_estocastico', 'Piso_teto_PLDbkup.xlsx'))

    # print(pld)
    

    ### Initializing the Variables

    objetos_M = {}     #Alteração_1

    for yy in range(4): #Alteração_1
        leng = 60
        coefBS0 = np.array([0.01, 0.5])
        dt = 1 / 254
        t = np.arange(1,leng+1)
        NSamples = 1E4

        aux2 = pd.read_csv(f'{dados_path}/' + name + ' M+' + str(yy) + ' SE -> VWAP.csv')
        aux2 = aux2.drop('Unnamed: 0', axis = 1)

        dates = pd.DataFrame(aux2, columns=['data'])
        dates['index'] = range(len(aux2))               #Alteração_1
        dates['data'] = pd.to_datetime(dates['data'], format='%Y-%m-%d')
        dates = dates.sort_values(by='data')

        Prices = aux2['VWAP'].iloc[dates['index']]
        a = np.isnan(Prices)

        dates = dates['data']

        Prices = np.interp(dates, dates[a == 0], Prices[a == 0])
        prices = Prices
        Returns = np.log(prices)

        PLD = np.zeros((len(dates), 2))

        for ii in range(len(dates)):
            if dates.iloc[ii].year <= pld.iloc[0,0]:
                PLD[ii,:] = np.log(pld.iloc[0,1:3])
            else:
                ss = 1
                while dates.iloc[ii].year > pld.iloc[ss, 0] and ss < pld.shape[0] - 1:
                     ss += 1
                PLD[ii, :] = np.log(pld.iloc[ss, 1:3])

        ### Estimation


        alpha = 1E-4 #0 #MUDEI
        Prices2 = prices


        coefMR0 = np.array([0.001, 1])
        coefMR = np.zeros((prices.shape[0]-leng,2))

        coefLMRJ0= np.array([0.01,0.4,0.1,0.1,0.1])
        coefLMRJ = np.zeros((prices.shape[0] - leng, 5))

        ALMRJ = np.zeros((Returns.shape[0] - leng, leng)) #1/8

        logPricesLMRJ_IN = np.zeros((Returns.shape[0] -  leng, leng+1)) #1/8
        logPricesLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, leng+1)) #1/8

        logPricesSqrLMRJ_IN = np.zeros((Returns.shape[0] -  leng, leng + 1)) #1/8
        logPricesSqrLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, leng + 1)) #1/8

        rmseLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        rmseLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        mapeLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        mapeLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8

        corrLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        corrLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        maeLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        maeLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        mbeLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        mbeLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        mseLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        mseLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        ioaLMRJ_IN = np.zeros((Returns.shape[0] -  leng, 1)) #1/8
        ioaLMRJ_OUT = np.zeros((Returns.shape[0] -  leng, 1)) #1/8


        fLMRJ_T = np.zeros((Returns.shape[0] -  leng, 2 * len(t))) #1/8

        errorLMRJ = np.zeros((Returns.shape[0] -  leng, 2)) #1/8

        ErrorLMRJ = np.zeros((Returns.shape[0] -  leng, leng)) #1/8

        L = np.zeros((Returns.shape[0] -  leng, len(t)+1)) #MUDEI #1/8
        M = np.zeros((Returns.shape[0] -  leng, len(t)+1)) #MUDEI #1/8
        U = np.zeros((Returns.shape[0] -  leng, len(t)+1)) #MUDEI #1/8

        SignLMRJ1_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #plot #1/8
        SignLMRJ2_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #plot #1/8
        SignLMRJ3_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #plot #1/8


        SignLMRJ = np.zeros((len(t), 3, Returns.shape[0] -  leng)) #1/8
        SignData = np.zeros((len(t), 3, Returns.shape[0] -  leng)) #1/8
        Acertou = np.zeros((Returns.shape[0] -  leng, len(t)))  #1/8
        SignLMRJ1 = np.zeros((Returns.shape[0] -  leng, len(t))) #1/8
        SignLMRJ2 = np.zeros((Returns.shape[0] -  leng, len(t))) #1/8
        SignLMRJ3 = np.zeros((Returns.shape[0] -  leng, len(t))) #1/8

        signPred = np.zeros((prices.shape[0] -  leng, leng)) #1/8
        signData = np.zeros((prices.shape[0] -  leng, leng)) #1/8

        MR_VAR05 = np.zeros((Returns.shape[0] -  leng,15,2))             #Risco      #1/8
        MR_CVAR05 = np.zeros((Returns.shape[0] - leng,15,2))            #Risco       #1/8

        lags = 10

        coefLevel = np.zeros((Returns.shape[0] - leng, lags + 1)) #1/8

        LevelPredTot = np.zeros((Returns.shape[0] - leng, 2 * leng + 2)) #1/8

        len2 = 254

        ### Fit


        for jj in range(Returns.shape[0] -  leng): #1/8

            lPld = PLD[jj:jj + 2 * leng+1, :] # incluí + 1
            while lPld.shape[0] < 2 * leng+1:                                        #1/8 #Alteração_1
                lPld = np.concatenate((lPld, [lPld[-1,:]]), axis=0)           #1/8

            data = Returns[jj:jj+leng+1] # incluí + 1, intervalo aberto à direita

            Data = Returns[jj:jj+2*leng+1] # incluí + 1, intervalo aberto à direita

            while len(Data) < 2 * leng+1:                                           #1/8   #Alteração_1
                Data = np.concatenate((Data, [Data[-1]]), axis=0)            #1/8

            LevelPred = np.zeros(Data.shape[0]+1)

            dataB = Returns[jj : jj + leng+1] # incluí + 1, intervalo aberto à direita

            DataB = Returns[jj : jj + 2 * leng +1] # incluí + 1, intervalo aberto à direita

            while len(DataB) < 2 * leng+1:                                          #1/8   #Alteração_1
                DataB = np.concatenate((DataB, [DataB[-1]]), axis=0)         #1/8

            dataB2 = DataB ** 2

            Pdata = Prices[jj : jj + leng+1] # incluí + 1, intervalo aberto à direita

            PData = Prices[jj : jj + 2 * leng+1] # incluí + 1, intervalo aberto à direita

            while len(PData) < 2 * leng+1:                                           #1/8        #Alteração_1
                PData = np.concatenate((PData, [PData[-1]]), axis=0)          #1/8

            Pdata2 = PData[leng:] # PData(len+1:end) em matlab
            S0 = data[0]
            S02 = Data[leng]
            P0 = Pdata2[0]


            ### Mean-Reverting with Jumps
            LBLMRJ = np.array([-15,0.1,0,-2,0]) #NOVO       #Pedro
            UBLMRJ = np.array([15,1,1,2,1])
            OF = lambda coef: ObjFunMRLJumps_20230629ReturnsB(data, coef, coefLMRJ[max(0, jj-1), :], t, dt, S0, alpha)
            coefLMRJ[jj, :] = least_squares(OF, coefLMRJ0, bounds=(LBLMRJ, UBLMRJ)).x # ftol=1e-14, xtol=1e-14, gtol=1e-14, verbose=1, max_nfev = 5000).x

            eva_IN = evaluate(leng, S0, coefLMRJ[jj,:], dt, LevelPred[0:leng+1], DataB[0:leng+1], dataB2[0:leng+1], data, Data[leng:], P0, type = "in")
            fLMRJ_IN = eva_IN[1]
            logPricesLMRJ_IN[jj,:] = eva_IN[3]
            logPricesSqrLMRJ_IN[jj,:] = eva_IN[5]
            rmseLMRJ_IN[jj,:] = eva_IN[7]
            mapeLMRJ_IN[jj,:] = eva_IN[9]
            corrLMRJ_IN[jj,:] = eva_IN[11]
            maeLMRJ_IN[jj,:] = eva_IN[13]
            mbeLMRJ_IN[jj,:] = eva_IN[15]
            mseLMRJ_IN[jj,:] = eva_IN[17]
            ioaLMRJ_IN[jj,:] = eva_IN[19]

            eva_OUT = evaluate(leng, S02, coefLMRJ[jj,:], dt, LevelPred[leng+1:], DataB[leng:], dataB2[leng:], data, Data[leng:], P0, type = 'out') #Mudança
            fLMRJ_OUT = eva_OUT[1]
            logPricesLMRJ_OUT[jj,:] = eva_OUT[3]
            logPricesSqrLMRJ_OUT[jj,:] = eva_OUT[5]
            rmseLMRJ_OUT[jj,:] = eva_OUT[7]
            mapeLMRJ_OUT[jj,:] = eva_OUT[9]
            corrLMRJ_OUT[jj,:] = eva_OUT[11]
            maeLMRJ_OUT[jj,:] = eva_OUT[13]
            mbeLMRJ_OUT[jj,:] = eva_OUT[15]
            mseLMRJ_OUT[jj,:] = eva_OUT[17]
            ioaLMRJ_OUT[jj,:] = eva_OUT[19]
            ALMRJ[jj,:] = eva_OUT[21]

            E = Error(prices, leng, coefLMRJ[jj,:], dt, LevelPred, data, Data,fLMRJ_IN, fLMRJ_OUT) #Pedro, retirei S0

            ErrorLMRJ[jj,:] = E[1]
            errorLMRJ[jj,:] = E[3]
            fLMRJ_T[jj,:] = E[5]

            mc = MC(leng, S02, coefLMRJ[jj,:], dt, LevelPred, int(NSamples), t, lPld) #Pedro: mudei de S0 para S02. Mudei de 1/dt para dt.


            X = mc[1] #MUDEI

            L[jj,:] = mc[3] #MUDEI
            M[jj,:] = mc[5] #MUDEI
            U[jj,:] = mc[7] #MUDEI


            signLMRJ=(np.exp(X[1:,:])-P0)/P0

            signPred[jj,:] = eva_OUT[21]  #(ALMRJ);

            estag = 0.005                                            #Pedro, linha nova

            acertar = Acertar(t, estag, signLMRJ, NSamples, P0, Pdata2)  #Pedro: estag é nova entrada

            signData[jj,:] = acertar[1]  #(AT) #MUDEI
            SignLMRJ[:,:,jj]= acertar[3] #AUX #MUDEI
            SignData[:,:,jj]= acertar[5] #AUX2 #MUDEI
            Acertou[jj,] = acertar[7] #acertou #MUDEI

            SignLMRJ1[jj,:] = acertar[3][:,0]   #AUX(:,1)'; #MUDEI
            SignLMRJ2[jj,:] = acertar[3][:,1]   #AUX(:,2)'; #MUDEI
            SignLMRJ3[jj,:] = acertar[3][:,2]   #AUX(:,3)'; #MUDEI

            len_pred = 15 # usar 5, 10 ou 15, escolha do usuário                       #Pedro, linha nova

            MRJ_plot(dates, Prices, lPld, logPricesSqrLMRJ_OUT[jj,:], logPricesLMRJ_OUT[jj,:], jj, leng, len_pred, yy) #Pedro, len_pred é nova entrada

            risco_mr = Risco_20240412(signLMRJ[1:16, :])                                      #Risco        #1/8

            MR_VAR05[jj,:,0]= risco_mr[1]                                                        #Risco    #1/8
            MR_CVAR05[jj,:,0]= risco_mr[3]                                                                 #1/8


        objetos_M[yy] = {                           #Alteração_1
            'dates': dates,                         #Alteração_1
            'PLD': PLD,                             #Alteração_1
            'Prices': Prices,                       #Alteração_1
            'Returns': Returns,                     #Alteração_1
            'coefLMRJ': coefLMRJ,                   #Alteração_1
            'MR_VAR05': MR_VAR05,                   #Alteração_1
            'MR_CVAR05': MR_CVAR05,                 #Alteração_1
            'rmseLMRJ_IN': rmseLMRJ_IN,             #Alteração_1
            'rmseLMRJ_OUT': rmseLMRJ_OUT,           #Alteração_1
            'logPricesLMRJ_IN': logPricesLMRJ_IN,   #Alteração_1
            'logPricesLMRJ_OUT': logPricesLMRJ_OUT, #Alteração_1
            'errorLMRJ': errorLMRJ                  #Alteração_1
        }                                           #Alteração_1

        print(f"Completed iteration for yy = {yy}") #Alteração_1


        

    # Gráfico de probabilidades                #Pedro. Código novo.

    for yy in range(4): #Alteração_1

        dates = objetos_M[yy]['dates'] #Alteração_1
        PLD = objetos_M[yy]['PLD'] #Alteração_1
        Prices = objetos_M[yy]['Prices'] #Alteração_1
        Returns = objetos_M[yy]['Returns'] #Alteração_1
        coefLMRJ = objetos_M[yy]['coefLMRJ'] #Alteração_1

        for ll in range(Returns.shape[0] - leng): #1/8

            # Objetos que foram definidos no início e serão usados nessa mudança: PLD, Prices, Returns, leng, t, dt, NSamples. #15/7

            print(f"ll: {ll}")

            lPld_ll = PLD[ll:ll + 2 * leng+1, :] # incluí + 1                                      #15/7

            while lPld_ll.shape[0] < 2 * leng+1:                                        #1/8   #Alteração_1
                lPld_ll = np.concatenate((lPld_ll, [lPld_ll[-1,:]]), axis=0)           #1/8

            Data_ll = Returns[ll:ll+2*leng+1] # incluí + 1, intervalo aberto à direita             #15/7

            while len(Data_ll) < 2 * leng+1:                                           #1/8             #Alteração_1
                Data_ll = np.concatenate((Data_ll, [Data_ll[-1]]), axis=0)            #1/8

            LevelPred_ll = np.zeros(Data_ll.shape[0]+1)                                            #15/7
            S02_ll = Data_ll[leng]                                                                 #15/7

            PData_ll = Prices[ll : ll + 2 * leng+1] # incluí + 1, intervalo aberto à direita       #15/7

            while len(PData_ll) < 2 * leng+1:                                           #1/8                 #Alteração_1
                PData_ll = np.concatenate((PData_ll, [PData_ll[-1]]), axis=0)            #1/8

            Pdata2_ll = PData_ll[leng:] # PData(len+1:end) em matlab                               #15/7
            P0_ll = Pdata2_ll[0]                                                                   #15/7

            mc_ll = MC(leng, S02_ll, coefLMRJ[ll,:], dt, LevelPred_ll, int(NSamples), t, lPld_ll) #15/7

            X_ll = mc_ll[1]                                                                       #15/7

            signLMRJ_ll=(np.exp(X_ll[1:,:]) - P0_ll)/P0_ll                                        #15/7

            estag_plot = 0.005 #escolha do usuário

            acertar_plot = Acertar_plot(estag_plot, signLMRJ_ll[1:16, :], int(NSamples))          #15/7

            SignLMRJ1_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #Alteração_1
            SignLMRJ2_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #Alteração_1
            SignLMRJ3_plot2 = np.zeros((Returns.shape[0] -  leng, 15))                #Alteração_1

            SignLMRJ1_plot2[ll,:] = acertar_plot[1][:,0]   #AUX(:,1)'; #plot
            SignLMRJ2_plot2[ll,:] = acertar_plot[1][:,1]   #AUX(:,2)'; #plot
            SignLMRJ3_plot2[ll,:] = acertar_plot[1][:,2]   #AUX(:,3)'; #plot

            plot_prob(SignLMRJ1_plot2, SignLMRJ2_plot2, SignLMRJ3_plot2, ll, leng, dates, yy)

            print(f"Completed iteration for yy = {yy}") # Log successful iteration  #Alteração_1
        
                
    # Gráfico da análise de risco para cada data

    for yy in range(4): #Alteração_1

        dates = objetos_M[yy]['dates']     #Alteração_1
        Returns = objetos_M[yy]['Returns']  #Alteração_1
        MR_VAR05 = objetos_M[yy]['MR_VAR05'] #Alteração_1
        MR_CVAR05 = objetos_M[yy]['MR_CVAR05'] #Alteração_1

        for tt in range(Returns.shape[0] - leng):                                #Risco                                                      #1/8

            print(f"tt: {tt}")                                                                                                               #Risco

            plot_risk(MR_VAR05, MR_CVAR05, tt, 0, leng, dates, Title = "Análise de Risco (Modelo Estocástico para o Curto Prazo)", yy=yy)           #Risco

        print(f"Completed iteration for yy = {yy}") # Log successful iteration  #Alteração_1

    # Ploting 1-day-ahead predictions versus data
    for yy in range(4): #Alteração_1

        dates = objetos_M[yy]['dates']    #Alteração_1
        Returns = objetos_M[yy]['Returns']  #Alteração_1

        logPricesLMRJ_IN = objetos_M[yy]['logPricesLMRJ_IN']  #Alteração_1
        logPricesLMRJ_OUT = objetos_M[yy]['logPricesLMRJ_OUT'] #Alteração_1

        logPricesLMRJ_T = np.concatenate((logPricesLMRJ_IN, logPricesLMRJ_OUT), axis = 1)

        ypoints = logPricesLMRJ_T[:,leng+1]  #1/8

        dates_prev = pd.concat([dates,pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])     #1/8

        fig = plt.figure(figsize=(15, 7))
        plt.plot(dates[0:-leng],Returns[0:-leng],'k', label='Data') #Mudança
        plt.plot(dates_prev[leng:-leng], ypoints, linewidth=1, color = 'm', label='Prediction') #Mudança      #1/8
        plt.title('MRJ')
        plt.xlabel('Time')
        plt.ylabel('Log-Prices')
        plt.legend(loc='upper right')
        
        # Salvar o gráfico em um arquivo HTML
        output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}', '1-day-ahead_predictions')
        os.makedirs(output_dir, exist_ok=True)
        
        # Converter o gráfico matplotlib para um gráfico Plotly
        plotly_fig = tls.mpl_to_plotly(fig)
            
            
        # Converter o objeto Plotly para JSON
        plot_json = plotly_fig.to_plotly_json()
        
        # Save the JSON file
        output_file = os.path.join(output_dir, f'estocastico.json')
        with open(output_file, 'w') as f:
            json.dump(plot_json, f)

    ## Plotting Normalized Error

    for yy in range(4): #Alteração_1

        dates = objetos_M[yy]['dates'] #Alteração_1
        errorLMRJ = objetos_M[yy]['errorLMRJ'] #Alteração_1

        dates_prev = pd.concat([dates,pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])     #Alteração_1

        ypoints = errorLMRJ[:,0] # representa errorLMRJ_IN

        fig = plt.figure(figsize=(15, 7))
        plt.plot(dates_prev[leng:-leng],np.median(errorLMRJ[:,0])*np.ones(errorLMRJ.shape[0]),'k') #Mudança   #1/8
        plt.plot(dates_prev[leng:-leng], ypoints, linewidth=1, color = 'm') #Mudança                          #1/8
        plt.title('MRJ')
        plt.xlabel('Time')
        plt.ylabel('L^2-Error')
        
        # Salvar o gráfico em um arquivo HTML
        output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}', 'normalized_error_in')
        os.makedirs(output_dir, exist_ok=True)
            
        
        # Converter o gráfico matplotlib para um gráfico Plotly
        plotly_fig = tls.mpl_to_plotly(fig)
            

        # Converter o objeto Plotly para JSON
        plot_json = plotly_fig.to_plotly_json()
        
        # Save the JSON file
        output_file = os.path.join(output_dir, f'estocastico.json')
        with open(output_file, 'w') as f:
            json.dump(plot_json, f)
            
        ypoints = errorLMRJ[:,1] # representa errorLMRJ_OUT

        fig = plt.figure(figsize=(15, 7))
        plt.plot(dates_prev[leng:-leng],np.median(errorLMRJ[:,1])*np.ones(errorLMRJ.shape[0]),'k') #Mudança    #1/8
        plt.plot(dates_prev[leng:-leng], ypoints, linewidth=1, color = 'm') #Mudança                           #1/8
        plt.title('MRJ')
        plt.xlabel('Time')
        plt.ylabel('L^2-Error')
        
        # Salvar o gráfico em um arquivo HTML
        output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}', 'normalized_error_out')
        os.makedirs(output_dir, exist_ok=True)
            
        
        # Converter o gráfico matplotlib para um gráfico Plotly
        plotly_fig = tls.mpl_to_plotly(fig)
            

        # Converter o objeto Plotly para JSON
        plot_json = plotly_fig.to_plotly_json()
        
        # Save the JSON file
        output_file = os.path.join(output_dir, f'estocastico.json')
        with open(output_file, 'w') as f:
            json.dump(plot_json, f)


        

    ## Plotting the RMSE

    for yy in range(4): #Alteração_1

        dates = objetos_M[yy]['dates']   #Alteração_1
        rmseLMRJ_IN = objetos_M[yy]['rmseLMRJ_IN'] #Alteração_1
        rmseLMRJ_OUT = objetos_M[yy]['rmseLMRJ_OUT'] #Alteração_1

        dates_prev = pd.concat([dates,pd.Series(pd.date_range(start=dates.max() + pd.Timedelta(days=1), periods=leng, freq='D'))])     #Alteração_1

        rmseLMRJ_T = np.concatenate((rmseLMRJ_IN, rmseLMRJ_OUT), axis = 1)

        ypoints = rmseLMRJ_T[:,0] # representa rsmeLMRJ_IN

        fig = plt.figure(figsize=(15, 7))
        plt.plot(dates_prev[leng:-leng],np.median(rmseLMRJ_T[:,0])*np.ones(rmseLMRJ_T.shape[0]),'k') #Mudança   #1/8
        plt.plot(dates_prev[leng:-leng], ypoints, linewidth=1, color = 'm') #Mudança                            #1/8
        plt.title('MRJ')
        plt.xlabel('Time')
        plt.ylabel('RMSE')

        # Salvar o gráfico em um arquivo HTML
        output_dir = os.path.join('web', 'static', 'tasks_saida', 'estocastico', f'M+{yy}', 'rmse_in')
        os.makedirs(output_dir, exist_ok=True)
            
        
        # Converter o gráfico matplotlib para um gráfico Plotly
        plotly_fig = tls.mpl_to_plotly(fig)
            

        # Converter o objeto Plotly para JSON
        plot_json = plotly_fig.to_plotly_json()
        
        # Save the JSON file
        output_file = os.path.join(output_dir, f'estocastico.json')
        with open(output_file, 'w') as f:
            json.dump(plot_json, f)

        ypoints = rmseLMRJ_T[:,1] # representa rmseLMRJ_OUT

        plt.figure(figsize=(15, 7))
        plt.plot(dates_prev[leng:-leng],np.median(rmseLMRJ_T[:,1])*np.ones(rmseLMRJ_T.shape[0]),'k') #Mudança         #1/8
        plt.plot(dates_prev[leng:-leng], ypoints, linewidth=1, color = 'm') #Mudança                                  #1/8
        plt.title('MRJ')
        plt.xlabel('Time')
        plt.ylabel('RMSE')
        
    
        # Converter o gráfico matplotlib para um gráfico Plotly
        plotly_fig = tls.mpl_to_plotly(fig)
            

        # Converter o objeto Plotly para JSON
        plot_json = plotly_fig.to_plotly_json()
        
        # Save the JSON file
        output_file = os.path.join(output_dir, f'estocastico.json')
        with open(output_file, 'w') as f:
            json.dump(plot_json, f)
        
    print(f"[INFO] FINALIZADO!")
        